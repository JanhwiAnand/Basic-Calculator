const express = require('express');
const cors = require('cors');
const env = require('./config/env');
const authRoutes = require('./routes/authRoutes');
const leaveRoutes = require('./routes/leaveRoutes');
const userRoutes = require('./routes/userRoutes');
const { errorMiddleware } = require('./middleware/errorMiddleware');
const logger = require('./utils/logger');

const app = express();
//app.use applies middleware to the application
app.use(cors({ origin: 'http://localhost:3000' }));//request from this address will be allowed
app.use(express.json());//to read the request body(express don't understand the json body format)
app.use(express.urlencoded({ extended: true }));//to parse url

app.use('/api/auth', authRoutes);
app.use('/api/leaves', leaveRoutes);
app.use('/api/users', userRoutes);

app.use(errorMiddleware);

app.listen(env.PORT, () => {
  logger.info(`Server running on port ${env.PORT}`);
});const asyncHandler = require('express-async-handler');
const axios = require('axios');
const jwt = require('jsonwebtoken');
const CustomError = require('../utils/customError');
const constants = require('../utils/constants');
const env = require('../config/env');
const logger = require('../utils/logger');
const { handleAxiosError } = require('../utils/errorHandler');


const forgotPassword = asyncHandler(async (req, res) => {
  const { firstname, lastname, email } = req.body;
  console.log(req.body);
  if (!firstname || !lastname || !email) {
    throw new CustomError(
      constants.errorMessages.MISSING_FIELDS,
      constants.status.BAD_REQUEST
    );
  }

  try {
    const response = await axios.post(`${env.SPRING_BOOT_API}/api/auth/forgot-password`, {
      firstname,
      lastname,
      email
    });

    logger.info(`Forgot password request processed for ${email}`);
    res.json({success:true,message:response.data});
    console.log(response.data);

   
  } catch (error) {
    res.status(400).json({success:false,message:"Invalid user details"});
    handleAxiosError(error, res);
  }
});

const login = asyncHandler(async (req, res) => {
  const { email, password } = req.body;

  if (!email || !password) {
    throw new CustomError(
      constants.errorMessages.MISSING_FIELDS,
      constants.status.BAD_REQUEST
    );
  }

  try {
    // Send login request to Spring Boot API
    const response = await axios.post(`${env.SPRING_BOOT_API}/api/auth/login`, {
      email,
      password,
    });

    const userRole = response.data.role;

    // Ensure role is either ADMIN or EMPLOYEE
    if (!['ADMIN', 'EMPLOYEE'].includes(userRole)) {
      throw new CustomError('Invalid role returned from backend', constants.status.BAD_REQUEST);
    }

    // Generate JWT with single role
    const token = jwt.sign(
      {
        sub: email,
        role: userRole, // Fixed: single role instead of roles array
      },
      env.JWT_SECRET,
      { expiresIn: constants.JWT_EXPIRES_IN }
    );

    logger.info(`User ${email} logged in successfully`);

    res.status(constants.status.OK).json({
      accessToken: token,
      user: response.data,
    });
  } catch (error) {
    handleAxiosError(error, res);
  }
});

module.exports = { login,forgotPassword };const { body, query, param, validationResult } = require('express-validator');
const CustomError = require('../utils/customError');
const constants = require('../utils/constants');
const logger = require('../utils/logger');

const validateForgotPassword = (req, res, next) => {
  const { firstname, lastname, email } = req.body;

  if (!firstname || !lastname || !email) {
    return res.status(400).json({ message: 'All fields are required.' });
  }

  const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
  if (!emailRegex.test(email)) {
    return res.status(400).json({ message: 'Invalid email format.' });
  }

  next();
};

const validateLogin = [
  body('email')
    .notEmpty()
    .withMessage('Email is required')
    .isEmail()
    .withMessage('Invalid email format')
    .matches(constants.EMAIL_REGEX)
    .withMessage('Email must end with @infinite.com'),
  body('password')
    .notEmpty()
    .withMessage('Password is required')
    .isLength({ min: 8 })
    .withMessage('Password must be at least 8 characters long')
    .matches(constants.PASSWORD_REGEX)
    .withMessage('Password must contain at least one uppercase letter, one lowercase letter, one number, and one special character'),
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      const errorMessages = errors.array().map((error) => error.msg);
      logger.warn(`Validation failed: ${errorMessages.join(', ')}`);
      throw new CustomError(errorMessages, constants.status.BAD_REQUEST);
    }
    next();
  },
];

const validateLeaveRequest = [
  body('employeeEmail')
    .notEmpty()
    .withMessage('Employee email is required')
    .isEmail()
    .withMessage('Invalid email format')
    .matches(constants.EMAIL_REGEX)
    .withMessage('Email must end with @infinite.com'),
  body('startDate')
    .notEmpty()
    .withMessage('Start date is required')
    .isDate()
    .withMessage('Invalid start date format'),
  body('endDate')
    .notEmpty()
    .withMessage('End date is required')
    .isDate()
    .withMessage('Invalid end date format'),
  body('reason')
    .notEmpty()
    .withMessage('Reason is required'),
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      const errorMessages = errors.array().map((error) => error.msg);
      logger.warn(`Validation failed: ${errorMessages.join(', ')}`);
      throw new CustomError(errorMessages, constants.status.BAD_REQUEST);
    }
    next();
  },
];

const validateLeaveId = [
  param('leaveId')
    .isInt({ min: 1 })
    .withMessage('Leave ID must be a positive integer'),
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      const errorMessages = errors.array().map((error) => error.msg);
      logger.warn(`Validation failed: ${errorMessages.join(', ')}`);
      throw new CustomError(errorMessages, constants.status.BAD_REQUEST);
    }
    next();
  },
];

const validateRejectLeave = [
  body('declineReason')
    .notEmpty()
    .withMessage('Decline reason is required'),
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      const errorMessages = errors.array().map((error) => error.msg);
      logger.warn(`Validation failed: ${errorMessages.join(', ')}`);
      throw new CustomError(errorMessages, constants.status.BAD_REQUEST);
    }
    next();
  },
];

const validateUsernameQuery = [
  query('employeeEmail')
    .notEmpty()
    .withMessage('Employee email is required idhar')
    .isEmail()
    .withMessage('Invalid email format')
    .matches(constants.EMAIL_REGEX)
    .withMessage('Email must end with @infinite.com'),
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      const errorMessages = errors.array().map((error) => error.msg);
      logger.warn(`Validation failed: ${errorMessages.join(', ')}`);
      throw new CustomError(errorMessages, constants.status.BAD_REQUEST);
    }
    next();
  },
];

const validateHistoryQuery = [
  query('employeeEmail')
    .notEmpty()
    .withMessage('Employee email is required')
    .isEmail()
    .withMessage('Invalid email format')
    .matches(constants.EMAIL_REGEX)
    .withMessage('Email must end with @infinite.com'),
  query('year')
    .optional()
    .isInt({ min: 2000, max: 2100 })
    .withMessage('Year must be between 2000 and 2100'),
  query('page')
    .optional()
    .isInt({ min: 0 })
    .withMessage('Page must be a non-negative integer'),
  query('size')
    .optional()
    .isInt({ min: 1 })
    .withMessage('Size must be a positive integer'),
  query('sortBy')
    .optional()
    .isIn(['startDate', 'endDate', 'status'])
    .withMessage('Sort by must be one of: startDate, endDate, status'),
  query('direction')
    .optional()
    .isIn(['ASC', 'DESC'])
    .withMessage('Direction must be ASC or DESC'),
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      const errorMessages = errors.array().map((error) => error.msg);
      logger.warn(`Validation failed: ${errorMessages.join(', ')}`);
      throw new CustomError(errorMessages, constants.status.BAD_REQUEST);
    }
    next();
  },
];

const validateUserUpdate = [
  body('employeeEmail')
    .notEmpty()
    .withMessage('Employee email is required')
    .isEmail()
    .withMessage('Invalid email format')
    .matches(constants.EMAIL_REGEX)
    .withMessage('Email must end with @infinite.com'),
  body('firstName')
    .optional()
    .isString()
    .withMessage('First name must be a string'),
  body('lastName')
    .optional()
    .isString()
    .withMessage('Last name must be a string'),
  (req, res, next) => {
    const errors = validationResult(req);
    if (!errors.isEmpty()) {
      const errorMessages = errors.array().map((error) => error.msg);
      logger.warn(`Validation failed: ${errorMessages.join(', ')}`);
      throw new CustomError(errorMessages, constants.status.BAD_REQUEST);
    }
    next();
  },
];

module.exports = {
  validateForgotPassword,
  validateLogin,
  validateLeaveRequest,
  validateLeaveId,
  validateRejectLeave,
  validateUsernameQuery,
  validateHistoryQuery,
  validateUserUpdate,
};
const express = require('express');
const { login,forgotPassword } = require('../controllers/authController');
const { validateLogin,validateForgotPassword} = require('../middleware/validationMiddleware');


const router = express.Router();

router.post('/login', validateLogin, login);
router.post('/forgot-password', validateForgotPassword, forgotPassword);

module.exports = router;


