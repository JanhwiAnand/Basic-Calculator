package com.example.ems.service;

import com.example.ems.dto.ForgotPasswordRequest;
import com.example.ems.dto.ResetPasswordRequest;
import com.example.ems.dto.UserDto;
import com.example.ems.entity.PasswordHistory;
import com.example.ems.entity.User;
import com.example.ems.repository.PasswordHistoryRepository;
import com.example.ems.repository.UserRepository;

import lombok.RequiredArgsConstructor;

import java.time.LocalDateTime;
import java.util.List;
import java.util.Optional;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import org.springframework.http.HttpStatus;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.stereotype.Service;
import org.springframework.web.server.ResponseStatusException;

@Service
@RequiredArgsConstructor
public class UserServiceImpl implements UserService {
	private final PasswordHistoryRepository passwordHistoryRepository;
    private final UserRepository userRepository;
    private final BCryptPasswordEncoder passwordEncoder;
    private static final Logger logger = LoggerFactory.getLogger(UserServiceImpl.class);
    private static final String PASSWORD_PATTERN = "^(?=.*[a-z])(?=.*[A-Z])(?=.*\\d)(?=.*[@$!%*?&])[A-Za-z\\d@$!%*?&]{8,}$";

    @Override
    public User createUser(UserDto userDto) {
        logger.info("Creating user with email: {}", userDto.email());
        if (!userDto.email().endsWith("@infinite.com")) {
            logger.error("Invalid email domain for user: {}", userDto.email());
            throw new IllegalArgumentException("Email must belong to the infinite.com domain");
        }

        String password = userDto.password();
        if (!password.matches(PASSWORD_PATTERN)) {
            logger.error("Invalid password for user: {}", userDto.email());
            throw new IllegalArgumentException("Password must be at least 8 characters long, contain at least one uppercase letter, one lowercase letter, one digit, and one special character (@$!%*?&)");
        }

        User user = new User();
        user.setEmail(userDto.email());
        user.setPassword(passwordEncoder.encode(password));
        user.setRole(userDto.role());
        user.setFirstname(userDto.firstname());
        user.setLastname(userDto.lastname());
        user.setCity(userDto.city());
        user.setState(userDto.state());
        user.setCountry(userDto.country());
        user.setDate_of_joining(userDto.date_of_joining());
        user.setDepartment(userDto.department());
        user.setPhnno(userDto.phnno());
        return userRepository.save(user);
    }

    @Override
    public User getUserByEmail(String email) {
        return userRepository.findByEmail(email)
                .orElseThrow(() -> new RuntimeException("User not found with email: " + email));
    }

    @Override
    public User updateUser(User user) {
        logger.info("Updating user with email: {}", user.getEmail());
        if (!user.getEmail().endsWith("@infinite.com")) {
            logger.error("Invalid email domain for user: {}", user.getEmail());
            throw new IllegalArgumentException("Email must belong to the infinite.com domain");
        }

        if (user.getPassword() != null && !user.getPassword().isEmpty()) {
            if (!user.getPassword().matches(PASSWORD_PATTERN)) {
                logger.error("Invalid password for user: {}", user.getEmail());
                throw new IllegalArgumentException("Password must be at least 8 characters long, contain at least one uppercase letter, one lowercase letter, one digit, and one special character (@$!%*?&)");
            }
            user.setPassword(passwordEncoder.encode(user.getPassword()));
        }

        return userRepository.save(user);
    }
    //forgot-password
    public boolean validateUserForPasswordReset(ForgotPasswordRequest request) {
    	Optional<User>userOpt=userRepository.findByEmail(request.getEmail());
    	if(userOpt.isEmpty()) {
    		return false;
    	}
    	User users=userOpt.get();
    	logger.info("User found with email:{}",request.getEmail());
    	if (users.getFirstname().equalsIgnoreCase(request.getFirstname()) &&
    	        users.getLastname().equalsIgnoreCase(request.getLastname())) {
    	        logger.info("First name and last name match for email: {}", request.getEmail());
    	        return true;
    	    } else {
    	      
    	        return false;
    	    }
   }

	@Override
	public String resetPassword(ResetPasswordRequest request) {
	    User user = userRepository.findByEmail(request.getEmail())
	        .orElseThrow(() -> new RuntimeException("User not found"));

	    // Get last 6 passwords
	    List<PasswordHistory> lastPasswords = passwordHistoryRepository
	        .findTop6ByUserOrderByChangedAtDesc(user);

	    // Check if new password matches any previous one
	    for (PasswordHistory old : lastPasswords) {
	        if (passwordEncoder.matches(request.getNewPassword(), old.getPassword())) {
	            throw new IllegalArgumentException("New password must not match any of the last 6 passwords.");
	        }
	    }

	    // Save new encoded password to user
	    String encodedNew = passwordEncoder.encode(request.getNewPassword());
	    user.setPassword(encodedNew);
	    userRepository.save(user);

	    // Add new password to history
	    PasswordHistory ph = new PasswordHistory();
	    ph.setUser(user);
	    ph.setPassword(encodedNew);
	    ph.setChangedAt(LocalDateTime.now());
	    passwordHistoryRepository.save(ph);

	    return "Password reset successful";
	}

  
}
  @GetMapping("/profile")
    public User getProfile(HttpServletRequest request) {
        String email = (String) request.getAttribute("email");
        return userService.getUserByEmail(email);
    }package com.example.ems.controller;


import com.example.ems.dto.UserDto;
import com.example.ems.entity.User;
import com.example.ems.service.UserService;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.validation.Valid;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.access.prepost.PreAuthorize;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.web.bind.annotation.*;

@RestController
@RequestMapping("/api/users")
public class UserController {

    @Autowired
    private UserService userService;

    @Autowired
    private BCryptPasswordEncoder passwordEncoder;

    @PostMapping
    @PreAuthorize("hasRole('ADMIN')")
    public User createUser(@Valid @RequestBody UserDto userDto) {
        return userService.createUser(userDto);
    }
   


    @GetMapping("/profile")
    public User getProfile(HttpServletRequest request) {
        String email = (String) request.getAttribute("email");
        return userService.getUserByEmail(email);
    }

    @PutMapping("/profile")
    public User updateProfile(@RequestBody UserDto userDto, HttpServletRequest request) {
        String email = (String) request.getAttribute("email");
        User user = userService.getUserByEmail(email);
        user.setEmail(userDto.email());
        if (userDto.password() != null && !userDto.password().isEmpty()) {
            user.setPassword(passwordEncoder.encode(userDto.password()));
        }
        user.setRole(userDto.role());
        return userService.updateUser(user);
    }
}




const express = require('express');
const router = express.Router();
const { authMiddleware } = require('../middleware/authMiddleware');
const { validateUsernameQuery, validateUserUpdate } = require('../middleware/validationMiddleware');
const { getUserProfile, updateUserProfile, addUser } = require('../controllers/userController');

router.post('/', authMiddleware, addUser); // Add this line for POST /api/users
router.get('/profile', authMiddleware, validateUsernameQuery, getUserProfile);
router.put('/profile', authMiddleware, validateUserUpdate, updateUserProfile);

module.exports = router;const axios = require('axios');
const { handleAxiosError } = require('../utils/errorHandler');
const env = require('../config/env');

const getUserProfile = async (req, res) => {
  try {
    const response = await axios.get(`${env.SPRING_BOOT_API}/api/users/profile`, {
      headers: { Authorization: req.headers.authorization },
    });
    res.status(response.status).json(response.data);
  } catch (error) {
    handleAxiosError(error, res);
  }
};

const updateUserProfile = async (req, res) => {
  try {
    const response = await axios.put(`${env.SPRING_BOOT_API}/api/users/profile`, req.body, {
      headers: { Authorization: req.headers.authorization },
    });
    res.status(response.status).json(response.data);
  } catch (error) {
    handleAxiosError(error, res);
  }
};

// Add the new controller function for adding users
const addUser = async (req, res) => {
   console.log(req.body)
  try {
    const response = await axios.post(`${env.SPRING_BOOT_API}/api/users`, req.body, {
      headers: { Authorization: req.headers.authorization },
    }
 );
    console.log("problem")
    console.log('Request headers:', { Authorization: req.headers.authorization });
    res.status(response.status).json(response.data);
  } catch (error) {
    console.log('Error forwarding to Spring Boot:', error.response?.status, error.response?.data);
    handleAxiosError(error, res);
  }
};

module.exports = { getUserProfile, updateUserProfile, addUser };
// User Reducer: Manages user-related state
const initialState = {
  users: [],
  loading: false,
  error: null,
};

const userReducer = (state = initialState, action) => {
  switch (action.type) {
    case 'ADD_USER_REQUEST':
      return { ...state, loading: true, error: null };
    case 'ADD_USER_SUCCESS':
      return { ...state, users: [...state.users, action.payload], loading: false };
    case 'ADD_USER_FAILURE':
      return { ...state, error: action.payload, loading: false };
    default:
      return state;
  }
};

export default userReducer;// User Actions: Handles user-related operations (e.g., add user)
import axios from 'axios';

export const addUser = (userData, token) => async dispatch => {
  dispatch({ type: 'ADD_USER_REQUEST' });
  try {
    const response = await axios.post('http://localhost:5000/api/users', userData, {
      headers: { Authorization: `Bearer ${token}` },
    });
    dispatch({ type: 'ADD_USER_SUCCESS', payload: response.data });
  } catch (error) {
    dispatch({ type: 'ADD_USER_FAILURE', payload: error.response?.data?.errors[0] || 'Failed to add user' });
  }
};

export const getToken = state => state.auth.token;
export const getUser = state => state.auth.user;
export const getAuthError = state => state.auth.error;
export const getAuthLoading = state => state.auth.loading;
export const getCurrentLeaves = state => state.leaves.currentLeaves;
export const getAppliedLeaves = state => state.leaves.appliedLeaves;
export const getLeaveHistory = state => state.leaves.leaveHistory || { content: [] };
export const getLeaveBalances = state => state.leaves.leaveBalances;
export const getLeaveError = state => state.leaves.error;
export const getLeaveLoading = state => state.leaves.loading;
export const getPendingLeaves = state => state.leaves.pendingLeaves;
export const getAppliedLeavesByDateRange = state => state.leaves.appliedLeavesByDateRange || [];
//for forgot password part
export const getAuthMessage=state=>state.auth.message;

//for reset password
export const getResetPasswordLoading=(state)=>state.auth.loading;
export const getResetPasswordMessage=(state)=>state.auth.message;
export const getResetPasswordError=(state)=>state.auth.error;
